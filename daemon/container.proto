/*
 * This file is part of GyroidOS
 * Copyright(c) 2013 - 2020 Fraunhofer AISEC
 * Fraunhofer-Gesellschaft zur FÃ¶rderung der angewandten Forschung e.V.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU General Public License,
 * version 2 (GPL 2), as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GPL 2 license for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, see <http://www.gnu.org/licenses/>
 *
 * The full GNU General Public License is included in this distribution in
 * the file called "COPYING".
 *
 * Contact Information:
 * Fraunhofer AISEC <gyroidos@aisec.fraunhofer.de>
 */

syntax = "proto2";

option java_package = "de.fraunhofer.aisec.trustme";

message ContainerImageSize {
	required string image_name = 1; // virtual name of the image file in guestos
	required uint64 image_size = 2; // size (bytes) of the image file
	optional string image_file = 3; // name of alternat image file which overwrites image_name of guestos config
}

message ContainerVnetConfig {
	required string if_name = 1; // name of virtual veth endpoint in container
	required bool configure = 2; // should cmld configure the interface or leave it unconfigured
	optional string if_rootns_name = 3; // name of virtual veth endpoint in rootns (will be autogenerated by cmld)
	optional string if_mac = 4; // mac of virtual veth endpoint inside container (will be autogenerated)
	// TODO Define configuration, for now just use hardcoded default config in c_net
}

message ContainerPnetConfig {
	required string netif = 1; // name or mac of physical network intarface mapped to container
	repeated string mac_filter = 2; // mac of allowed client devices on that netfif
}

enum ContainerUsbType {
	GENERIC = 1;
	TOKEN = 2;
	PIN_ENTRY = 3;
}

message ContainerUsbConfig {
	required string id = 1;
	required string serial = 2;
	required bool assign = 3 [default = false];
	required ContainerUsbType type = 4 [default = GENERIC];
}

/**
 * Type of container KVM|CONTAINER
 */
enum ContainerType {
	CONTAINER = 1;
	KVM = 2	;
}

enum ContainerTokenType {
	NONE = 1;
	SOFT = 2;
	USB = 3;
	PKCS11 = 4;
}

message ContainerConfig {
	reserved 20;

	// user configurable, non unique
	required string name = 1;
	// name of GuestOS, e.g. android
	required string guest_os = 2;
	// (minimal) version of GuestOS; will be updated if container is started with a more recent GuestOS version.
	optional uint64 guestos_version = 3;

	// complete image sizes from GuestOS for user partitions
	repeated ContainerImageSize image_sizes = 4;

	// ram limit of container, set ram_limit to 0 for unlimited ram
	optional uint32 ram_limit = 5 [ default = 0 ];      // unit = MBytes

	required fixed32 color = 6;

	// type of container, e.g. KVM or CONTAINER
	required ContainerType type = 7 [ default = CONTAINER ];

	repeated string init_env = 8;	// environment variables

	optional bool userns = 10 [default = true];

	optional string assign_cpus = 11; // cpus "m-n", e.g., "0-1"

	// Flags indicating the allows for containers:
	optional bool allow_autostart = 17 [default = false];
	optional bool allow_system_time = 18 [default = false];

	// TODO: add further features as necessary

	optional string dns_server = 21;
	optional bool netns = 22 [default = true];

	// a list of network interfaces assigned to this container
	repeated ContainerPnetConfig net_ifaces = 23;

	// a list of modules explicitely allowed for this container
	repeated string allow_module = 24;

	// a list of devices explicitely allowed for this container
	repeated string allow_dev = 25;

	// a list of devices exclusively assigned to this container
	repeated string assign_dev = 26;

	// list of virtual network interface configuration
	repeated ContainerVnetConfig vnet_configs = 27;

	// list of usb interface configuration
	repeated ContainerUsbConfig usb_configs = 28;

	// number of pipes from c0 to this container
	// control erweitern: get container pipe fd
	// use bindmount mechanism from c_vol
	repeated string fifos = 29;

	required ContainerTokenType token_type = 30 [ default = SOFT ];

	optional bool usb_pin_entry = 31 [ default = false ];

	// enable module to support legacy xorg server
	optional bool enable_xorg_compat = 32 [ default = false ];

	// Specify PKCS#11 module the container should use
	// if the token_type is PKCS11
	optional string pkcs11_module = 33;
}

/**
 * The various states that a container can be in.
 * TODO must be kept in sync with definition in container.h!
 */
enum ContainerState {
	STOPPED = 1;
	STARTING = 2;
	BOOTING = 3;
	RUNNING = 4;
	FREEZING = 5;
	FROZEN = 6;
	ZOMBIE = 7;
	SHUTDOWN = 8;
	SETUP = 9;
	REBOOTING = 10;
}

/**
 * Must be kept in sync with definition in container.h!
 */
enum ContainerConnectivity {
	OFFLINE = 1;
	MOBILE_ONLY = 2;
	WIFI_ONLY = 3;
	MOBILE_AND_WIFI = 4;
}

enum ContainerTrust {
	SIGNED = 1;
	LOCALLY_SIGNED = 2;
	UNSIGNED = 3;
}

enum CryptfsMode {
	NOT_IMPLEMENTED = 1;
	AUTHENC = 2;
	ENCRYPT_ONLY = 3;
	INTEGRITY_ENCRYPT = 4;
	INTEGRITY_ONLY = 5;
}

/**
 * Represents the status of a single container.
 */
message ContainerStatus {
	required string uuid = 1;
	required string name = 2;
	required ContainerType type = 3;
	required ContainerState state = 4;
	required uint64 uptime = 5;
	required uint64 created = 6;
	required string guestos = 7;
	required ContainerTrust trust_level = 8;
	required CryptfsMode cryptfs_mode = 9;
	/* TBD more state values */
}
